// Generated by CoffeeScript 1.4.0
var CoffeeSprites, Image, Sprite, async, fs, gd, instance, path, sprite_count;

gd = require('node-gd');

async = require('async2');

fs = require('fs');

path = require('path');

instance = undefined;

CoffeeSprites = (function() {

  function CoffeeSprites(o) {
    o = o || {};
    o.image_path = o.image_path || '';
    o.sprite_path = o.sprite_path || '';
    o.sprite_url = o.sprite_url || '';
    o.manifest_file = o.manifest_file || path.join(o.sprite_path, 'sprite-manifest.json');
    this.o = o;
    this.sprites = {};
    this.flow = new async();
    this.read_manifest();
  }

  CoffeeSprites.prototype.read_manifest = function() {
    var data, name, _fn,
      _this = this;
    if (fs.existsSync(this.o.manifest_file)) {
      data = (JSON.parse(fs.readFileSync(this.o.manifest_file))) || {};
      _fn = function(name, sprite) {
        var i, png, _ref, _results;
        _this.sprites[name] = new Sprite(name, sprite.options);
        _ref = sprite.images;
        _results = [];
        for (i in _ref) {
          png = _ref[i];
          _results.push((function(png) {
            return _this.flow.serial(function() {
              return _this.sprites[name].add(png, arguments[arguments.length - 1]);
            });
          })(png));
        }
        return _results;
      };
      for (name in data.sprites) {
        _fn(name, data.sprites[name]);
      }
    }
  };

  CoffeeSprites.prototype.write_manifest = function() {
    var data, file, name;
    data = {
      sprites: {}
    };
    for (name in this.sprites) {
      data.sprites[name] = {
        options: this.sprites[name].o,
        images: []
      };
      for (file in this.sprites[name].images) {
        data.sprites[name].images.push(file);
      }
    }
    fs.writeFileSync(this.o.manifest_file, JSON.stringify(data, null, 2));
  };

  CoffeeSprites.prototype.extend = function(engine) {
    var g, generate_placeholder,
      _this = this;
    g = engine.o.globals;
    g.sprite_map = function(name, options) {
      var sprite;
      sprite = new Sprite(name, options);
      _this.sprites[name] = sprite;
      return name;
    };
    generate_placeholder = function(key, name, png) {
      if (typeof png !== 'undefined') {
        _this.flow.series(function() {
          return _this.sprites[name].add(png, arguments[arguments.length - 1]);
        });
      }
      return "SPRITE_" + key + "_PLACEHOLDER(" + name + ", " + (png || '') + ")";
    };
    g.sprite = function(sprite, png) {
      return generate_placeholder('URL_AND_IMAGE_POSITION', sprite, png);
    };
    g.sprite_url = function(sprite) {
      return generate_placeholder('URL', sprite);
    };
    g.sprite_position = function(sprite, png) {
      return generate_placeholder('POSITION', sprite, png);
    };
    g.sprite_width = function(sprite, png) {
      return generate_placeholder('WIDTH', sprite, png);
    };
    g.sprite_height = function(sprite, png) {
      return generate_placeholder('HEIGHT', sprite, png);
    };
    engine.on.end = function(css, done) {
      _this.flow["finally"](function(err) {
        var flow, name, sprite, _fn, _ref;
        if (err) {
          throw err;
        }
        css = css.replace(/SPRITE_(.+?)_PLACEHOLDER\((.+?), (.*?)\)/g, function(match, key, name, png) {
          var image, sprite;
          sprite = _this.sprites[name];
          image = sprite.images[png];
          switch (key) {
            case 'POSITION':
              return image.coords();
            case 'URL':
              return sprite.digest_url();
            case 'URL_AND_IMAGE_POSITION':
              return "url(" + (sprite.digest_url()) + ") " + (image.coords());
            case 'WIDTH':
              return image.px(image.width);
            case 'HEIGHT':
              return image.px(image.height);
          }
        });
        flow = new async();
        _ref = _this.sprites;
        _fn = function(sprite) {
          return flow.series(function() {
            sprite.render(this);
          });
        };
        for (name in _ref) {
          sprite = _ref[name];
          _fn(sprite);
        }
        flow["finally"](function() {
          _this.write_manifest();
          done(null, css);
        });
      });
    };
  };

  return CoffeeSprites;

})();

sprite_count = 0;

Sprite = (function() {

  function Sprite(name, o) {
    if (typeof name !== 'string') {
      o = name;
      name = '';
    }
    this.name = name || 'sprite-' + (++sprite_count);
    o = o || {};
    o.repeat = o.repeat || 'no-repeat';
    this.images = {};
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.png = undefined;
    this.digest = '';
    this.o = o;
    return;
  }

  Sprite.prototype.add = function(file, cb) {
    var _this = this;
    if (typeof this.images[file] !== 'undefined') {
      cb(null, this.images[file]);
    } else {
      this.images[file] = new Image((this.o.path || '') + file, this.x, this.y, function(err, image) {
        var blob, key, _ref;
        if (err) {
          return cb(err);
        }
        _this.width = Math.max(_this.width, image.width);
        _this.y = _this.height += image.height + (_this.o.spacing || 0);
        blob = '';
        for (key in _this.o) {
          blob += '' + key + ':' + _this.o[key] + '|';
        }
        _ref = _this.images;
        for (key in _ref) {
          image = _ref[key];
          blob += image + '|';
        }
        _this.digest = require('crypto').createHash('md5').update(blob).digest('hex').substr(-10);
        return cb(null);
      });
    }
  };

  Sprite.prototype.render = function(cb) {
    var flow, key, sprite, transparency, _fn;
    sprite = this;
    if (sprite.width < 1) {
      return cb("sprite map was created but no images added");
    }
    if (fs.existsSync(sprite.digest_file())) {
      return cb("no change would occur");
    }
    sprite.png = gd.createTrueColor(sprite.width, sprite.height);
    transparency = sprite.png.colorAllocateAlpha(0, 0, 0, 127);
    sprite.png.fill(0, 0, transparency);
    sprite.png.colorTransparent(transparency);
    sprite.png.alphaBlending(0);
    sprite.png.saveAlpha(1);
    flow = new async();
    _fn = function(image) {
      return flow.series(function() {
        var done;
        done = this;
        image.open(function() {
          var x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
          switch (sprite.o.repeat) {
            case 'no-repeat':
              image.src.copy(sprite.png, image.x, image.y, 0, 0, image.width, image.height);
              break;
            case 'repeat-x':
              for (x = _i = 0, _ref = sprite.width, _ref1 = image.width; 0 <= _ref ? _i <= _ref : _i >= _ref; x = _i += _ref1) {
                image.src.copy(sprite.png, x, image.y, 0, 0, image.width, image.height);
              }
              break;
            case 'repeat-y':
              for (y = _j = 0, _ref2 = sprite.height, _ref3 = image.height; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; y = _j += _ref3) {
                image.src.copy(sprite.png, image.x, y, 0, 0, image.width, image.height);
              }
          }
          done();
        });
      });
    };
    for (key in sprite.images) {
      _fn(sprite.images[key]);
    }
    flow["finally"](function() {
      var file, files, pattern, _i, _len;
      pattern = sprite.digest_file().replace(/-[\w\d+]+\.png$/, '-*.png');
      files = require('glob').sync(pattern);
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        fs.unlinkSync(file);
      }
      sprite.png.savePng(sprite.digest_file(), 0, function() {
        console.log("Wrote " + (sprite.digest_file().replace(process.cwd() + '/', '')) + ".");
        cb(null, sprite.digest_file());
      });
    });
  };

  Sprite.prototype.digest_file = function() {
    return path.join(instance.o.sprite_path, "" + this.name + "-" + this.digest + ".png");
  };

  Sprite.prototype.digest_url = function() {
    return path.join(instance.o.sprite_url, "" + this.name + "-" + this.digest + ".png");
  };

  return Sprite;

})();

Image = (function() {

  function Image(file, x, y, cb) {
    var _this = this;
    this.file = file;
    this.x = x;
    this.y = y;
    this.src = undefined;
    this.height = undefined;
    this.width = undefined;
    this.absfile = path.join(instance.o.image_path, this.file + '.png');
    this.open(function(err) {
      if (err) {
        return cb(err);
      }
      _this.height = _this.src.height;
      _this.width = _this.src.width;
      return cb(null, _this);
    });
  }

  Image.prototype.toString = function() {
    return "Image#file=" + this.file + ",x=" + this.x + ",y=" + this.y + ",width=" + this.width + ",height=" + this.height;
  };

  Image.prototype.open = function(cb) {
    var _this = this;
    return gd.openPng(this.absfile, function(err, src) {
      if (err) {
        return cb(err);
      }
      _this.src = src;
      return cb(null, _this);
    });
  };

  Image.prototype.px = function(i) {
    if (i === 0) {
      return 0;
    } else {
      return i + 'px';
    }
  };

  Image.prototype.coords = function() {
    return this.px(this.x * -1) + ' ' + this.px(this.y * -1);
  };

  return Image;

})();

module.exports = function(options) {
  instance = new CoffeeSprites(options);
  return function(engine) {
    instance.extend(engine);
    return instance;
  };
};
