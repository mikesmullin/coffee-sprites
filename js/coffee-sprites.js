// Generated by CoffeeScript 1.4.0
var CoffeeSprites, Image, Sprite, async, fs, gd, instance, sprite_count;

gd = require('node-gd');

async = require('async2');

fs = require('fs');

instance = void 0;

CoffeeSprites = (function() {

  function CoffeeSprites(o) {
    o = o || {};
    o.image_path = o.image_path || './';
    o.sprite_path = o.sprite_path || './';
    o.sprite_url = o.sprite_url || './';
    this.o = o;
    this.sprites = {};
    this.flow = new async();
  }

  CoffeeSprites.prototype.extend = function(engine) {
    var g, generate_placeholder,
      _this = this;
    g = engine.o.globals;
    g.sprite_map = function(name, options) {
      var sprite;
      sprite = new Sprite(name, options);
      return _this.sprites[sprite.name] = sprite;
    };
    generate_placeholder = function(key, sprite, png) {
      if (typeof png !== 'undefined') {
        _this.flow.series(function() {
          return sprite.add(png, this);
        });
      }
      return "SPRITE_" + key + "_PLACEHOLDER(" + sprite.name + ", " + (png || '') + ")";
    };
    g.sprite = function(sprite, png) {
      return generate_placeholder('URL_AND_IMAGE_POSITION', sprite, png);
    };
    g.sprite_url = function(sprite) {
      return generate_placeholder('URL', sprite);
    };
    g.sprite_position = function(sprite, png) {
      return generate_placeholder('POSITION', sprite, png);
    };
    g.sprite_width = function(sprite, png) {
      return generate_placeholder('WIDTH', sprite, png);
    };
    g.sprite_height = function(sprite, png) {
      return generate_placeholder('HEIGHT', sprite, png);
    };
    engine.on.end = function(css, done) {
      _this.flow["finally"](function() {
        var flow, name, sprite, _fn, _ref;
        css = css.replace(/SPRITE_(.+?)_PLACEHOLDER\((.+?), (.*?)\)/g, function(match, key, name, png) {
          var image, sprite;
          sprite = _this.sprites[name];
          image = sprite.images[png];
          switch (key) {
            case 'POSITION':
              return image.coords();
            case 'URL':
              return sprite.digest_url();
            case 'URL_AND_IMAGE_POSITION':
              return "url(" + (sprite.digest_url()) + ") " + (image.coords());
            case 'WIDTH':
              return image.px(image.width);
            case 'HEIGHT':
              return image.px(image.height);
          }
        });
        flow = new async();
        _ref = _this.sprites;
        _fn = function(sprite) {
          return flow.series(function() {
            sprite.render(this);
          });
        };
        for (name in _ref) {
          sprite = _ref[name];
          _fn(sprite);
        }
        flow["finally"](function() {
          done(null, css);
        });
      });
    };
  };

  return CoffeeSprites;

})();

sprite_count = 0;

Sprite = (function() {

  function Sprite(name, o) {
    if (typeof name !== 'string') {
      o = name;
      name = '';
    }
    this.name = name || 'sprite-' + (++sprite_count);
    o = o || {};
    o.repeat = o.repeat || 'no-repeat';
    this.images = {};
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.png = void 0;
    this.digest = void 0;
    this.o = o;
    return;
  }

  Sprite.prototype.add = function(file, callback) {
    var image,
      _this = this;
    if (typeof this.images[file] !== 'undefined') {
      this.images[file];
      callback(null);
    } else {
      image = this.images[file] = new Image(file, this.x, this.y, function(err) {
        var blob, key, _ref;
        if (err) {
          return callback(err);
        }
        _this.width = Math.max(_this.width, image.width);
        _this.y = _this.height += image.height + (_this.o.spacing || 0);
        blob = '';
        for (key in _this.o) {
          blob += '' + key + ':' + _this.o[key] + '|';
        }
        _ref = _this.images;
        for (key in _ref) {
          image = _ref[key];
          blob += image + '|';
        }
        _this.digest = require('crypto').createHash('md5').update(blob).digest('hex').substr(-10);
        return callback(null);
      });
    }
  };

  Sprite.prototype.render = function(callback) {
    var flow, key, sprite, transparency, _fn;
    sprite = this;
    sprite.png = gd.createTrueColor(sprite.width, sprite.height);
    transparency = sprite.png.colorAllocateAlpha(0, 0, 0, 127);
    sprite.png.fill(0, 0, transparency);
    sprite.png.colorTransparent(transparency);
    sprite.png.alphaBlending(0);
    sprite.png.saveAlpha(1);
    flow = new async();
    _fn = function(image) {
      return flow.series(function() {
        var done;
        done = this;
        image.open(function() {
          var x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
          switch (sprite.o.repeat) {
            case 'no-repeat':
              image.png.copy(sprite.png, image.x, image.y, 0, 0, image.width, image.height);
              break;
            case 'repeat-x':
              for (x = _i = 0, _ref = sprite.width, _ref1 = image.width; 0 <= _ref ? _i <= _ref : _i >= _ref; x = _i += _ref1) {
                image.png.copy(sprite.png, x, image.y, 0, 0, image.width, image.height);
              }
              break;
            case 'repeat-y':
              for (y = _j = 0, _ref2 = sprite.height, _ref3 = image.height; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; y = _j += _ref3) {
                image.png.copy(sprite.png, image.x, y, 0, 0, image.width, image.height);
              }
          }
          done();
        });
      });
    };
    for (key in sprite.images) {
      _fn(sprite.images[key]);
    }
    flow["finally"](function() {
      var file, files, pattern, _i, _len;
      pattern = sprite.digest_file().replace(/-[\w\d+]+\.png$/, '-*.png');
      files = require('glob').sync(pattern);
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        fs.unlinkSync(file);
      }
      sprite.png.savePng(sprite.digest_file(), 0, function() {
        console.log("Wrote " + (sprite.digest_file().replace(process.cwd() + '/', '')) + ".");
        callback(null, sprite.digest_file());
      });
    });
  };

  Sprite.prototype.digest_file = function() {
    return instance.o.sprite_path + this.name + '-' + this.digest + '.png';
  };

  Sprite.prototype.digest_url = function() {
    return instance.o.sprite_url + this.name + '-' + this.digest + '.png';
  };

  return Sprite;

})();

Image = (function() {

  function Image(file, x, y, callback) {
    var _this = this;
    this.file = file;
    this.x = x;
    this.y = y;
    this.png = void 0;
    this.height = void 0;
    this.width = void 0;
    this.absfile = instance.o.image_path + this.file + '.png';
    this.open(function(err) {
      if (err) {
        return callback(err);
      }
      _this.height = _this.png.height;
      _this.width = _this.png.width;
      return callback(null);
    });
    return;
  }

  Image.prototype.toString = function() {
    return "Image#file=" + this.file + ",x=" + this.x + ",y=" + this.y + ",width=" + this.width + ",height=" + this.height;
  };

  Image.prototype.open = function(callback) {
    var _this = this;
    return gd.openPng(this.absfile, function(err, png) {
      if (err) {
        return callback(err);
      }
      _this.png = png;
      return callback(null);
    });
  };

  Image.prototype.px = function(i) {
    if (i === 0) {
      return 0;
    } else {
      return i + 'px';
    }
  };

  Image.prototype.coords = function() {
    return this.px(this.x * -1) + ' ' + this.px(this.y * -1);
  };

  return Image;

})();

module.exports = function(options) {
  instance = new CoffeeSprites(options);
  return function(engine) {
    instance.extend(engine);
    return instance;
  };
};
